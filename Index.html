<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>  
  <link rel="stylesheet" href="logica.js">
  <link rel="stylesheet" href="Paleta.css"> 
  <title>Document</title>
</head>
<body>
  <!-- Area do jogo -->
 <canvas id="background" class="pixel-art" width="500" height="300"
 			style="left: 0; top: 0; z-index: 0; position: absolute;">
 </canvas>
 <canvas id="foreground" class="pixel-art" width="500" height="300"
 			style="left: 0; top: 0; z-index: 1; position: absolute;">
 </canvas>

<script>

//************************************************************
//
//				~Constantes~
// 
//************************************************************
//scale para a pixel-art ("pixel-size")
const scale = 1;

//largura/altura da sprite
//final = w: 38 h: 32x2
const width = 56; 
const height = 104;

//largura/altura dos tiles
//se no final for o mesmo size, roll-up numa única var
const tileWidth = 38;
const tileHeight = 38;

//largura/altura scaled
const scaledWidth = scale * width;
const scaledHeight = scale * height;

//pixeis que a sprite viaja
const moveSpeed = 2;

//ciclo com as linhas na spriteSheet
const cycleLoop = [0, 0, 0, 0];

//quantidade de frames por draw
const frameLimit = 12;

//Enums:

//direções
const directions = {
   up: 2,
   down: 0,
   left: 3,
   right: 1,
}

//passagens
const passageParams = {
	posX: 0,
	posY: 1,
	passWidth: 2,
	passHeight: 3,
	connectsTo: 4,
}

//Temp debug stuff
let debugCount=0;
//************************************************************
//
//				~Variáveis~
// 
//************************************************************
//Posição da sprite em relação ao canvas
let positionX = tileWidth*2;
let positionY = tileHeight*2;


let currentLoopIndex = 0;
let frameCount = 0;

let currentDirection = directions.down;

//Declarado de início, para não "actualizar"
let hasInteracted = false;


let keyPresses = {};

//************************************************************
//
//				~Define e init do mapa~
// 
//************************************************************

//no final cleanup, dar rollup ás atribuições na função SetMapId()
//para ficarem só os "let"s
let map = new Image();
map.src = 'SpriteSheet/maptest0.png';


//era boa ideia criar objectos com Image att e Array att, mas...
let fore = new Image();
fore.src = '';
let mapId = 0;
let mapBounds ={};
setMapBounds(0);

let mapPassages ={};
setMapPassages(0);

let mapInteracts ={};
setMapInteracts(0);

//canvas para o que apareçe "á frente" da char
let canvasFluff = document.getElementById('foreground');

//canvas para background e char
let canvas = document.getElementById('background');
let ctx = canvas.getContext('2d');

//esta está só de kickstart, depois sai
map.onload = function(){
	fillCanvas(map);
}

let img = new Image();

//************************************************************
//
//				~Funções de draw~
// 
//************************************************************

//primeiro fill, á partida sai na versão final
function fillCanvas(map){
	canvas.width = map.width;
	canvas.height = map.height;
	canvasFluff.width = map.width;
	canvasFluff.height = map.height;
	ctx.drawImage(map,0,0);
}

//kickstart também
function loadImage(){
	img.src = 'SpriteSheet/hero1.png';
	//func onload corre at start, começa a animação
	img.onload = function() {
  		window.requestAnimationFrame(step);
	};
}

//function de tidy-up para dar trigger a todos os switch'es, na troca de mapa
function setMapId(n){
	mapId = n;
	setMapSrc(n);
	setMapPassages(n);
	setMapInteracts(n);
}

//parte "hardcode" de bounds/passagens/interactibles/src
function setMapPassages(mapId){
	
	switch(mapId)
	{
		//mapPassages array per passage = (posX,posY,width,height,connectsTO,new posX, new posY)
		case 0:

			mapPassages.passage1 = [tileWidth*11-10,tileHeight*2, tileWidth, tileHeight*3,1,tileWidth+10, tileHeight*4];
			mapPassages.passage2 = [];
			break;
		case 1:
			mapPassages.passage1 = [0,tileHeight*2,tileWidth,tileHeight*3,0,tileWidth*11-10,tileHeight*4];
			mapPassages.passage2 = [];
			break;
		case 2:
			mapPassages.passage1 = [];
			mapPassages.passage2 = [];
	}
}

function setMapSrc(mapId){
	
	switch(mapId)
	{
		case 0:
			map.src = 'SpriteSheet/maptest0.png';
			fore.src = '';
			break;
		case 1:
			map.src = 'SpriteSheet/maptest1.png';
			fore.src = '';
			break;
		case 2:
			map.src = 'SpriteSheet/testTiledMap.png';
			fore.src = '';
			break;
	}
}

function setMapInteracts(mapId){

	switch(mapId)
	{
		//mapInteracts array per interact = (posX,posY,width,height,interactsWITH)
		case 0:
			mapInteracts.interact1 = [];
			mapInteracts.interact2 = [];
			break;
		case 1:
			mapInteracts.interact1 = [];
			mapInteracts.interact2 = [];
			break;
		case 2:
			mapInteracts.interact1 = [tileWidth*3, tileHeight*2, tileWidth, tileHeight,0];
			mapInteracts.interact2 = [tileWidth*5, tileHeight*2, tileWidth, tileHeight,0];
			mapInteracts.interact3 = [tileWidth*7, tileHeight*2, tileWidth, tileHeight,0];
			break;
	}
}

function setMapBounds(mapId){

	switch(mapId)
	{
		//[posX, posY, coliderWidth, coliderHeight]
		case 0:
			mapBounds.top = [0, -(tileHeight/2), tileWidth*12, tileHeight*0.5];
			mapBounds.left = [0, 0, tileWidth*0.5, tileHeight*10];
			mapBounds.bottom = [0, tileHeight*10, tileWidth*12, tileHeight];
			mapBounds.right1 = [tileWidth*12, 0, tileWidth, tileHeight*4];
			mapBounds.right2 = [tileWidth*12, tileHeight*7,tileWidth,tileHeight*4];
			mapBounds.tree1 = [tileWidth*2, tileHeight*2,tileWidth,tileHeight];
			mapBounds.tree2 = [tileWidth*8,tileHeight*8,tileWidth,tileHeight];
			break;
		case 1:
			break;
		case 2:

			mapBounds.bound1 = [tileWidth*3, tileHeight*2, tileWidth, tileHeight];
			mapBounds.bound2 = [tileWidth*5, tileHeight*2, tileWidth, tileHeight];
			mapBounds.bound3 = [tileWidth*7, tileHeight*2, tileWidth, tileHeight];
			mapBounds.bound4 = [0, 0, tileWidth*10, tileHeight*1];
			mapBounds.bound5 = [0, 0,tileWidth*0.9,tileHeight*10];
			mapBounds.bound6 = [tileWidth*9, 0,tileWidth*10,tileHeight*10];
			mapBounds.bound7 = [0, tileHeight*9,tileWidth*10,tileHeight*10];
			mapBounds.bound8 = [tileWidth*3, tileHeight*6, tileWidth, tileHeight];
			break;
	}
}


//************************************************************
//drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
//				   s= source 				d= destination(canvas)
//************************************************************

//func para lidar com a matemática
function drawFrame(frameX, frameY, canvasX, canvasY){
	//Primeiro o background
		ctx.drawImage(map,0,0);
	//depois a character
		ctx.drawImage(img,
						frameX * width, frameY * height, width, height,
						canvasX, canvasY, scaledWidth, scaledHeight);
	//e depois o fluff
		ctx.drawImage(fore,0,0);

}
//************************************************************
//
//				~kick-start~
// 
//************************************************************


//Aqui fica a func de start, depois do load state

//temporariamente carrega directo a primeira imagem
loadImage();

//************************************************************
//
//				TODO:  menu, load/save -------------------------------***
// 
//************************************************************

//************************************************************
//
//				Função main loop - step
// 
//************************************************************
function step(){
	ctx.clearRect(0,0, canvas.width, canvas.height);

	//hasMoved é re-declarada a false em cada instância step
	let hasMoved = false;
				
	//movimento x/y
	if (keyPresses.w) {
    	moveCharacter(0, -moveSpeed, directions.up);
    	hasMoved = true;
 	} else if (keyPresses.s) {
    	moveCharacter(0, moveSpeed, directions.down);
    	hasMoved = true;
  	}

  	if (keyPresses.a) {
    	moveCharacter(-moveSpeed, 0, directions.left);
    	hasMoved = true;
  	} else if (keyPresses.d) {
    	moveCharacter(moveSpeed, 0, directions.right);
    	hasMoved = true;
  	}

  	//hasInteracted é declarada no start-up, para não "actualizar"
  	//em cada step
  	if(keyPresses.j){
		if(hasInteracted == false)
		{
			checkInteract();
			hasInteracted = true;
		}
		else
		{
			hasInteracted = false;
		}
	}

	//fixed fps's virtuais
	if(hasMoved){
		frameCount++;
		//só arranca quando o counter bate no frameLimit
		if(frameCount >= frameLimit){
			frameCount = 0;
			//incrementa a posição X na SpriteSheet
			currentLoopIndex++;
			//chegando ao fim, volta ao inicio
			if(currentLoopIndex >= cycleLoop.length){
				currentLoopIndex = 0;
			}
		}
	}

	//char mantém idle stance quando pára de se mexer
	//TODO: criar loop á parte para idle animation ----------------------****
	if(!hasMoved){
		currentLoopIndex = 0;
		
	}

	//desenha tudo
	//						        	Este 0 passa a CurrentDirection (Y na SpriteSheet)
	drawFrame(cycleLoop[currentLoopIndex], 0, positionX, positionY);

	//recursion para o jogo andar
	window.requestAnimationFrame(step); 
}
//************************************************************
//
//				Função de movimento (deltas)
// 
//************************************************************
function moveCharacter(deltaX, deltaY, direction) {
//posX/posY == canto topleft da char
//minimo positionX é 0(esquerda), máximo é a largura da char+movespeed(delta)+largura do canvas

  if(positionX + deltaX > 0 && positionX+scaledWidth+deltaX< canvas.width){
  	if(checkColision(deltaX, deltaY))
  	{
  		positionX += deltaX;
  	}
  	
  }
  
  //ScaledHeight/2, para só detectar colisão nas "pernas"
  //metade para outer map, menos para sprite colision
  if(positionY+(scaledHeight/2) + deltaY > 0 && positionY+scaledHeight+ deltaY< canvas.height){
  	if(checkColision(deltaX, deltaY))
  	{
  		positionY += deltaY;
  	}
  }
  
  //checkDoor a cada incremento de posX/Y
  checkDoor();
  currentDirection = direction;
}

//verifica se "colide" com passagens, dá trigger a mapChange
function checkDoor(){

	let keys = Object.keys(mapPassages);
	
	keys.forEach((key, index) =>{
		let [posX, posY, passWidth, passHeight, connectsTo, newPosX, newPosY] = mapPassages[key];

		if(positionX > posX && positionX < posX+passWidth &&
			positionY > posY && positionY< posY+passHeight){
  		
  		positionX = newPosX;
  		positionY = newPosY;

  		//TODO: implementar transacção de mapas (wipe, translate, smthing) ------------------***
  		setMapId(connectsTo);

		}
	});		
}


//jeeeesus
function checkColision(deltaX, deltaY){

	//conta estranha, mas apenas para "feel" de colisão correcta
	let halfHeight = positionY+(scaledHeight/1.3)+3;

	let colideX = positionX+scaledWidth-3;
	let colideY = positionY+scaledHeight -3;

	//check declarado fora do ciclo forEach, caso algum acuse false, não
	//muda até checkColision voltar a ser called
	let check = true;
	

	//Object.keys é awsome, traduz todas as propriedades para uma array 
	//de strings (keys = ["top","bottom",left...])
	let keys = Object.keys(mapBounds);
	
	keys.forEach((key, index) =>{

		//atribui os valores em array a estas 4 vars
		let [posX, posY, coliderWidth, coliderHeight] = mapBounds[key];
		
		if(positionX+deltaX < posX+coliderWidth &&
		   colideX+deltaX > posX &&
		   halfHeight+deltaY < posY+coliderHeight &&
		   colideY+deltaY > posY)
			{
				
				check = false; 
			}
	});

	return check;
}

//************************************************************
//
//				Funções interact
// 
//************************************************************

function checkInteract(){
	//a minha ideia é criar uma "caixa" na currentDirection
	let interactX = positionX;
	let interactY = positionY;

	switch(currentDirection){
		case directions.up:
			interactY -= 38; //interactBoxSize - TEMP, vai ser mais próxima do size de um tile
			break;
		case directions.down:
			interactY += height + 38;
			break;
		case directions.left:
			interactX -= 38;
			break;
		case directions.right:
			interactX += width + 38;
			break;
	}

	let keys = Object.keys(mapInteracts);
	//mapInteracts array per interact = (posX,posY,interactWidth,interactHeight,interactsWITH)

	keys.forEach((key, index) =>{
		let [posX, posY, interactWidth, interactHeight, interactsWITH] = mapInteracts[key];

		//weird enuff, foi-me mais fácil fazer esta de && e ||, do que a colision normal
		if(interactX > posX && interactX < posX+interactWidth
			|| interactX + width > posX && interactX + width < posX+interactWidth
		 && interactY > posY && interactY< posY+interactHeight
		 	|| interactY + height > posY && interactY + height < posY+interactHeight
		 	){

  			getInteraction(interactsWITH);
  			interactX = positionX;
  			interactY = positionY;
  		}
  	});
}


//gere o tipo de interação (prompt com diálogo, get/set item)
function getInteraction(interactId){
	switch(interactId)
	{
		case 0:
			console.log("Interagio" + debugCount);
			debugCount++;
			break;
	}
}
//************************************************************
//
//				Funções keypress
// 
//************************************************************

//eventListeners
window.addEventListener('keydown', keyDownListener, false);
function keyDownListener(e){
	keyPresses[e.key] = true;
}

window.addEventListener('keyup', keyUpListener, false);
function keyUpListener(e){
	keyPresses[e.key] = false;
}

//************************************************************
//
//				Fim do script
// 
//************************************************************


//************************************************************
//
//				área temp
// 
//************************************************************
/*
function mapBounds(){
	
		mapChange();
		positionX = 0;
		positionY = 0;
	
}

function mapChange(){
	map.src = 'SpriteSheet/testmap2.png';
}
*/

</script>


</body>
</html>

