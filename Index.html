<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>  
  <link rel="stylesheet" href="logica.js">
  <link rel="stylesheet" href="Paleta.css"> 
  <title>Document</title>
</head>
<body>
  <!-- Area do jogo -->
 <canvas class="pixel-art" width="500" height="300">
 </canvas>

<script>

//************************************************************
//
//				~Constantes~
// 
//************************************************************
//scale para a pixel-art ("pixel-size")
const scale = 1;

//largura/altura da sprite
const width = 32; 
const height = 32;

//largura/altura scaled
const scaledWidth = scale * width;
const scaledHeight = scale * height;

//pixeis que a sprite viaja
const moveSpeed = 1;

//ciclo com a height na spriteSheet
const cycleLoop = [0, 1, 2, 3];

//quantidade de frames por draw
const frameLimit = 12;

//direções
const directions = {
   up: 2,
   down: 0,
   left: 3,
   right: 1,
}
const passageParams = {
	posX: 0,
	posY: 1,
	passWidth: 2,
	passHeight: 3,
	connectsTo: 4,
}



//************************************************************
//
//				~Variáveis~
// 
//************************************************************
//Posição da sprite em relação ao canvas
let positionX = 0;
let positionY = 0;

let currentLoopIndex = 0;
let frameCount = 0;

let currentDirection = directions.down;
let hasInteracted = false;


let keyPresses = {};

let map = new Image();
map.src = 'SpriteSheet/testmap.png';

let mapId = 0;
let mapPassages ={
	
};
setMapPassages(0);

let mapInteracts ={

};
setMapInteracts(0);

let canvas = document.querySelector('canvas');
let ctx = canvas.getContext('2d');

map.onload = function(){
	fillCanvas(map);
}

let img = new Image();


//************************************************************
//
//				~Funções de draw~
// 
//************************************************************
function fillCanvas(map){
	
	canvas.width = map.width;
	canvas.height = map.height;

	ctx.drawImage(map,0,0);
}
function loadImage(){
	img.src = 'SpriteSheet/teste2.png';
	//func onload corre at start, começa a animação
	img.onload = function() {
  		window.requestAnimationFrame(step);
	};
}


function setMapPassages(mapId){
	
	switch(mapId)
	{
		//mapPassages array per passage = (posX,posY,width,height,connectsTO,new posX, new posY)
		case 0:

			mapPassages.passage1 = [105,81,30,30,1,0,0];
			mapPassages.passage2 = [15,81,30,30,1,100,100];
			break;
		case 1:
			mapPassages.passage1 = [160,81,30,30,0,50,50];
			mapPassages.passage2 = [];
			break;
	}
}

function setMapSrc(mapId){
	
	switch(mapId)
	{
		case 0:
			map.src = 'SpriteSheet/testmap.png';
			break;
		case 1:
			map.src = 'SpriteSheet/testmap2.png';
			break;

	}
	
}

function setMapInteracts(mapId){

	switch(mapId)
	{
		//mapInteracts array per interact = (posX,posY,width,height,interactsWITH)
		case 0:
			mapInteracts.interact1 = [-10,-10,20,60,0];
			break;
		case 1:
			break;
	}
}

function setMapId(n){
	mapId = n;
	setMapSrc(n);
	setMapPassages(n);
	setMapInteracts(n);
}
//************************************************************
//drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
//				   s= source 				d= destination(canvas)
//************************************************************

//func para lidar com a matemática
function drawFrame(frameX, frameY, canvasX, canvasY){
		ctx.drawImage(map,0,0);
		ctx.drawImage(img,
						frameX * width, frameY * height, width, height,
						canvasX, canvasY, scaledWidth, scaledHeight);

}


//************************************************************
//
//				~kick-start~
// 
//************************************************************

loadImage();

//************************************************************
//
//				TODO: BattleState, menu, load/save 
// 
//************************************************************

//************************************************************
//
//				Função main loop - step
// 
//************************************************************
function step(){
	ctx.clearRect(0,0, canvas.width, canvas.height);

	//hasMoved é re-declarada a false em cada instância step
	let hasMoved = false;
				
	//movimento x/y
	if (keyPresses.w) {
    	moveCharacter(0, -moveSpeed, directions.up);
    	hasMoved = true;
 	} else if (keyPresses.s) {
    	moveCharacter(0, moveSpeed, directions.down);
    	hasMoved = true;
  	}

  	if (keyPresses.a) {
    	moveCharacter(-moveSpeed, 0, directions.left);
    	hasMoved = true;
  	} else if (keyPresses.d) {
    	moveCharacter(moveSpeed, 0, directions.right);
    	hasMoved = true;
  	}

	if(hasMoved){
		frameCount++;
		if(frameCount >= frameLimit){
			frameCount = 0;
			currentLoopIndex++;
			if(currentLoopIndex >= cycleLoop.length){
				currentLoopIndex = 0;
			}
		}
	}

	//interação com map
	if(keyPresses.j){
		if(hasInteracted == false)
		{
			checkInteract();
			hasInteracted = true;
			console.log("entrouAqui");
		}
		else
		{
			hasInteracted = false;
			console.log("entrouAli");
		}
	}
	

	//char mantém idle stance quando pára de se mexer
	if(!hasMoved){
		currentLoopIndex = 0;
		
	}
	drawFrame(cycleLoop[currentLoopIndex], currentDirection, positionX, positionY);

	//recursion para o jogo andar
	window.requestAnimationFrame(step); 
}
//************************************************************
//
//				Função de movimento (deltas)
// 
//************************************************************
function moveCharacter(deltaX, deltaY, direction) {
//posX/posY == canto topleft da char
//minimo positionX é 0(esquerda), máximo é a largura da char+movespeed(delta)+largura do canvas

  if(positionX + deltaX > 0 && positionX+scaledWidth+deltaX< canvas.width){
  	positionX += deltaX;
  }
  
  if(positionY + deltaY > 0 && positionY+ scaledHeight+ deltaY< canvas.height){
  	positionY += deltaY;
  //	mapBounds();
  }
  
  checkDoor();
  currentDirection = direction;
}

function checkDoor(){

	let keys = Object.keys(mapPassages);
	

	keys.forEach((key, index) =>{
		let [posX, posY, passWidth, passHeight, connectsTo, newPosX, newPosY] = mapPassages[key];

		if(positionX > posX && positionX < posX+passWidth &&
			positionY > posY && positionY< posY+passHeight){
  		
  		positionX = newPosX;
  		positionY = newPosY;
  		setMapId(connectsTo);

  		
		}
	});		
}

//************************************************************
//
//				Funções interact
// 
//************************************************************

function checkInteract(){
	let interactX = positionX;
	let interactY = positionY;

	switch(currentDirection){
		case directions.up:
			interactY -= 5; //interactBoxSize - TEMP
			break;
		case directions.down:
			interactY += height + 5;
			break;
		case directions.left:
			interactX -= 5;
			break;
		case directions.right:
			interactX += width + 5;
			break;
	}

	let keys = Object.keys(mapInteracts);
	//mapInteracts array per interact = (posX,posY,interactWidth,interactHeight,interactsWITH)

	keys.forEach((key, index) =>{
		let [posX, posY, interactWidth, interactHeight, interactsWITH] = mapInteracts[key];

		if(interactX > posX && interactX < posX+interactWidth &&
			interactY > posY && interactY< posY+interactHeight){

  			getInteraction(interactsWITH);
  			interactX = positionX;
  			interactY = positionY;
  		}
  	});
}

function getInteraction(interactId){
	switch(interactId)
	{
		case 0:
			window.alert("Interacted");
			break;
	}
}
//************************************************************
//
//				Funções keypress
// 
//************************************************************

window.addEventListener('keydown', keyDownListener, false);
function keyDownListener(e){
	keyPresses[e.key] = true;
}

window.addEventListener('keyup', keyUpListener, false);
function keyUpListener(e){
	keyPresses[e.key] = false;
}

//************************************************************
//
//				Fim do script
// 
//************************************************************


//************************************************************
//
//				área temp
// 
//************************************************************
/*
function mapBounds(){
	
		mapChange();
		positionX = 0;
		positionY = 0;
	
}

function mapChange(){
	map.src = 'SpriteSheet/testmap2.png';
}
*/
//************************************************************
//
//				no-scroll map:
// 
//************************************************************

/*
var map = {
    cols: 8,
    rows: 8,
    tsize: 64,
    tiles: [
        1, 3, 3, 3, 1, 1, 3, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 2, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 2, 1, 1, 1, 1,
        1, 1, 1, 1, 2, 1, 1, 1,
        1, 1, 1, 1, 2, 1, 1, 1,
        1, 1, 1, 1, 2, 1, 1, 1
    ],
    getTile: function (col, row) {
        return this.tiles[row * map.cols + col];
    }
};

Game.load = function () {
    return [
        Loader.loadImage('tiles', '../assets/tiles.png')
    ];
};

Game.init = function () {
    this.tileAtlas = Loader.getImage('tiles');
};

Game.update = function (delta) {
};

Game.render = function () {
    for (var c = 0; c < map.cols; c++) {
        for (var r = 0; r < map.rows; r++) {
            var tile = map.getTile(c, r);
            if (tile !== 0) { // 0 => empty tile
                this.ctx.drawImage(
                    this.tileAtlas, // image
                    (tile - 1) * map.tsize, // source x
                    0, // source y
                    map.tsize, // source width
                    map.tsize, // source height
                    c * map.tsize,  // target x
                    r * map.tsize, // target y
                    map.tsize, // target width
                    map.tsize // target height
                );
            }
        }
    }
};
*/
</script>


</body>
</html>

